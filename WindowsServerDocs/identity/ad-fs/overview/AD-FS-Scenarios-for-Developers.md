---
ms.assetid: 8a64545b-16bd-4c13-a664-cdf4c6ff6ea0
title: 開発者向けの AD FS のシナリオ
description: ''
author: billmath
ms.author: billmath
manager: femila
ms.date: 05/31/2017
ms.topic: article
ms.prod: windows-server-threshold
ms.technology: identity-adfs
ms.openlocfilehash: a2a88608f3989522b1ec1c123f29bd679db7e318
ms.sourcegitcommit: 0d0b32c8986ba7db9536e0b8648d4ddf9b03e452
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2019
ms.locfileid: "59877943"
---
# <a name="ad-fs-scenarios-for-developers"></a>開発者向けの AD FS のシナリオ

>適用先:Windows Server 2016

Windows Server 2016 AD FS 2016 での AD FS を使用すると、業界標準の OpenID Connect と OAuth 2.0 ベースの認証と承認を開発しているアプリケーションを追加し、それらのアプリケーションが AD FS に対して直接ユーザーを認証できます。    
  
AD FS 2016 には、Ws-federation、Ws-trust もサポートしていると、SAML プロトコルしプロファイルが以前のバージョンでサポートされています。  これらのプロトコルの開発者ガイドに関心がある場合は、こちらの記事を参照してください。  この記事で使用し、新しいプロトコル サポートを利用する方法に焦点を当てます。  
  
## <a name="why-modern-authentication"></a>なぜ最新の認証  
WS フェデレーションを使用した、AD FS のサインインの使用を継続できますが、Ws-trust、および場合と同様の SAML プロトコルは、次の利点を取得する新しいプロトコルを使用する前があります。  
  
* **シンプルさと一貫性**  
    * サインオンを有効にするのにには、Api およびパターンの同じセットを使用します。   
        *   複数の種類のアプリケーション (サーバー、デスクトップ、モバイル、ブラウザー)  
        *   複数のプラットフォーム (android、iOS、Windows)  
        *   企業ネットワーク内のアプリケーションまたはクラウドでホストされています。  
    * 既に Azure AD に対するユーザーの認証に使用できるライブラリの同じセットを使用します。  
* **柔軟性**  
    * 標準ユーザーの承認だけでなくより複雑なシナリオを有効にします。      
        * ? ユーザーが 1 つに承認フローの 3 本足の符号は、web アプリケーションや、別の web アプリまたはサービスに存在するリソースにアクセスするサービスします。    
        * ? 中間層サービス バックエンド API にアクセスするサーバー間のフロー  
        * ? JavaScript ベースのシングル ページ アプリケーション (SPA)  
* **業界のサポート**  
    * OAuth 2.0 と OpenID Connect を楽しむ幅の使用率、業界全体でこれらのパターンの知識は認証と承認にも Active Directory 環境の外部で有効にする際に役立つように  
  
## <a name="how-it-works-the-basics"></a>動作方法。基本  
AD FS の最新の認証は、同じツールと既に Azure AD に対するユーザーの認証に使用できるライブラリのセットを使用してアプリケーションを追加できます。   
  
AD FS のシナリオでもちろん、これは AD FS と Azure AD 認証と id プロバイダーとして機能するサーバー。  それ以外の場合、概念は正確に同じ: ユーザーが自分の資格情報の提供し、直接、またはリソースにアクセスするため、仲介者を使用して、トークンを取得します。  
  
最も基本的なシナリオでは、ユーザーまたは"リソース所有者の"、web アプリケーションにアクセスするブラウザーとの対話で構成されます。  
  
![開発者向けの AD FS](media/ADFS_DEV_1.png)  
  
リソースにアクセス トークンの要求を承認サーバー (AD FS) が開始されるため、web アプリケーションは「クライアント」と呼ばれます。  リソースは、web アプリ自体によってホストされる場合がありますか、ネットワークまたはインターネット上の web API とアクセス可能性があります。   ユーザーまたは「リソース所有者」は、承認サーバーへの資格情報を提供することでそのアクセス トークンを受信するクライアントの web アプリを承認します。    
  
## <a name="how-it-works-components"></a>動作方法: コンポーネント  
OAuth 2.0 と OpenID Connect のシナリオで AD FS のツールと Azure AD が id プロバイダーを使用するライブラリの同じセットを使用します。  これらのコンポーネントは次のとおりです。  
* Active Directory Authentication Library (ADAL): クライアント ライブラリを促進するユーザーの資格情報を収集、作成、トークン要求を送信して、結果として得られるトークンを取得します。    
* (Open Web Interface for .NET) の OWIN ミドルウェア。OWIN には、コミュニティ ベースのプロジェクトが、Microsoft が作成された一連のサーバー側ライブラリを web アプリケーションと OpenID Connect と OAuth 2.0 で web Api を保護するため  
  
これらのコンポーネントの役割は次の図に示します。  
  
![開発者向けの AD FS](media/ADFS_DEV_2.png)  
  
## <a name="modeling-these-scenarios-in-ad-fs-2016"></a>AD FS 2016 でこれらのシナリオをモデル化  
  
### <a name="application-groups"></a>アプリケーション グループ  
これらのシナリオで AD FS のポリシーを表現するには、アプリケーション グループと呼ばれる新しい概念を導入しました。  アプリケーション グループには、任意の数とアプリケーションの次の基本的な種類の組み合わせを含めることができます。  
  
  
  
アプリケーション グループ/アプリケーションの種類  |説明  |ロール    
---------|---------|---------  
ネイティブ アプリケーション     |  パブリック クライアントとも呼ばれる、pc またはデバイスで、ユーザーが操作を使用してを実行するクライアント アプリがこのものです。       | リソースへのユーザー アクセスの承認サーバー (AD FS) からのトークンを要求します。  HTTP ヘッダーとして、トークンを使用して、保護されたリソースに HTTP 要求を送信します。        
サーバー アプリケーション     |   サーバー上で実行され、ブラウザー経由でユーザー、一般にアクセスする web アプリケーション。  独自のクライアント 'シークレット' または資格情報を維持できるため、confidential クライアントも呼び出されます。      | リソースへのユーザー アクセスの承認サーバー (AD FS) からのトークンを要求します。  HTTP ヘッダーとして、トークンを使用して、保護されたリソースに HTTP 要求を送信します。               
Web API     |  リソースのエンド ユーザーがアクセスしています。 「証明書利用者」の新しい表現の役割も果たします。| クライアントによって取得したトークンを使用します。  
  
### <a name="differences-from-ad-fs-2012-r2"></a>AD FS 2012 R2 との違い  
アプリケーション グループは、AD FS 2012 R2 は、証明書利用者、クライアント、およびアプリケーションのアクセス許可として個別に公開されている信頼および承認の要素を結合します。  
  
次の表では、対応するアプリケーション信頼オブジェクトは作成により AD FS 2012 R2 で vs AD FS 2016 メソッドを比較します。  
  
Windows Server 2012 R2 の AD FS|PowerShell で|AD FS の管理  
---------|---------|---------  
ネイティブ クライアントを追加します。|追加 AdfsClient|該当なし  
クライアントとサーバー アプリケーションを追加します。|追加 AdfsClient|該当なし  
Web API を追加/リソース|追加 AdfsRelyingPartyTrust|証明書利用者信頼を作成します。  
  
AD FS 2016|PowerShell で|AD FS の管理  
---------|---------|---------  
ネイティブ クライアントを追加します。|Add-AdfsNativeClientApplication|ネイティブのアプリケーション グループを追加します。  
クライアントとサーバー アプリケーションを追加します。|追加 AdfsServerApplication|サーバー アプリケーション グループを追加します。  
Web API を追加/リソース|追加 AdfsWebApiApplication|Web API アプリケーション グループを追加します。  
  
### <a name="application-permissions-and-consent"></a>アプリケーションのアクセス許可と同意  
既定では、アプリケーション グループ内のクライアントは、同じグループ内のリソースへのアクセス許可します。  管理者は、特定のアプリケーションのアクセス許可を構成する必要はありません。  アプリケーション グループでは、管理者が許可されている、openid など user_impersonation スコープを指定することもできます。  次のシナリオの説明では、スコープのどちらのシナリオに必要なだけを指定します。  
  
AD FS では、管理者の同意のモデルを使用するため、リソースにアクセスするときに同意するユーザーは求められません。  アプリケーション グループを構成することで、管理者は有効なアプリケーションのすべてのユーザーに代わって同意を提供します。  
  
## <a name="supported-scenarios"></a>サポートされるシナリオ  
次のセクションでは、詳細をサポートするためのシナリオについて説明します。  
  
### <a name="tokens-used"></a>トークンの使用  
これらのシナリオの 3 つのトークンの種類を使用します。  
  
* **id_token:** ユーザーの id を表すために使用する JWT トークンです。 Id_token の"aud"または対象ユーザーの要求では、ネイティブ モードまたはサーバー アプリケーションのクライアント ID と一致します。  
* **access_token:** 使用される JWT トークンでの Oauth および OpenID 接続のシナリオと、リソースが消費するために使用します。  このトークンの"aud"または対象ユーザー クレームは、リソースまたは Web API の識別子と一致する必要があります。  
* **refresh_token:** このトークンは、経験にシングル サインオンを提供するユーザーの資格情報の収集の代わりに送信されます。  このトークンが発行され、AD FS によって使用されると、クライアントやリソースを読み取ることができません。    
  
### <a name="native-client-to-web-api"></a>Web API へのネイティブ クライアント  
このシナリオでは、AD FS 2016 の保護された Web API を呼び出すネイティブ クライアント アプリケーションのことができます。  
* ネイティブ クライアント アプリケーションは ADAL を使用して承認を送信して、トークンは、必要に応じて、ユーザーから資格情報の入力を求める、AD FS を要求し、送信、Web API への要求で HTTP ヘッダーとして生成されるトークン  
* [この部分はデモンストレーションのみを目的の]Web API は、アクセス トークンがクライアントによって送信した結果であり、それらをクライアントに送信する ClaimsPrincipal オブジェクトからの要求を読み取ります。  
  
![プロトコル フローの説明](media/ADFS_DEV_3.png)  
  
1.  ネイティブ クライアント アプリケーションは、ADAL のライブラリへの呼び出しでフローを開始します。  これは、場合、トリガー、ブラウザー ベースの承認エンドポイントの HTTP GET を AD FS:  
  
**承認要求:**  
取得 https://fs.contoso.com/adfs/oauth2/authorize?  
  
パラメーター|Value  
---------|---------  
response_type|「コード」  
resource|アプリケーション グループ内の Web API の RP ID (識別子)  
client_id|アプリケーション グループでネイティブ アプリケーションのクライアント Id  
redirect_uri|アプリケーション グループでネイティブ アプリケーションのリダイレクト URI  
  
**承認要求の応答:**  
ユーザーが署名されていない場合する前に、資格情報の入力が求められます。    
AD FS は、redirect_uri のクエリ コンポーネントでの"code"パラメーターとして、認証コードを返すことで応答します。  次に、例を示します。Http/1.1 302 検出場所:  **http://redirect_uri:80/?code=&lt; コード&gt;します。**  
  
2.  ネイティブ クライアントは、次のパラメーターと共に、コードを AD FS のトークン エンドポイントに送信します。  
  
**トークンの要求:**  
投稿 https://fs.contoso.com/adfs/oauth2/token  
  
パラメーター|値  
---------|---------  
grant_type|"authorization_code" 
code|1 から認証コード  
resource|アプリケーション グループ内の Web API の RP ID (識別子)  
client_id|アプリケーション グループでネイティブ アプリケーションのクライアント Id  
redirect_uri|アプリケーション グループでネイティブ アプリケーションのリダイレクト URI  
  
**トークン要求の応答:**  
AD FS は、access_token、refresh_token を本文に id_token と、HTTP 200 で応答します。  
  
3.  次に、ネイティブ アプリケーションでは、web API に HTTP 要求の承認ヘッダーとして、上記の応答の access_token の一部を送信します。  
  
### <a name="single-sign-on-behavior"></a>シングル サインオンの動作  
(既定) 1 時間、access_token はまだ有効だが、キャッシュ内と、新しい要求が AD FS へのトラフィックがトリガーされない内でそれ以降のクライアントを要求します。  Access_token は、ADAL によってキャッシュから自動的にフェッチされます。  
  
アクセス トークンを過ぎると、ADAL は自動的に送信されている (自動的に承認要求をスキップします)、AD FS のトークン エンドポイントに対してトークン ベースの更新要求を使用します。  
**更新トークンの要求。**  
投稿 https://fs.contoso.com/adfs/oauth2/token
   

パラメーター|Value|
---------|---------
grant_type|"refresh_token"|
resource|アプリケーション グループ内の Web API の RP ID (識別子)|
client_id|アプリケーション グループでネイティブ アプリケーションのクライアント Id
refresh_token|最初のトークン要求に対する応答の AD FS によって発行された更新トークン

  
  
**トークン要求の応答を更新します。**  
更新トークンが < SSO_period > 内にある場合は、新しいアクセス トークン要求が発生します。 ユーザーが資格情報を求められません。  詳細については、SSO の設定を参照してください[AD FS Single Sign On Settings](../../ad-fs/operations/AD-FS-2016-Single-Sign-On-Settings.md)  
  
更新トークンの有効期限が切れている場合、要求が HTTP 401 エラー"invalid_grant"と"error_description"と"MSIS9615:Refresh_token パラメーターで受け取った更新トークンが期限切れ"です。 この場合、ADAL は、新しい承認要求は 1 つ目のように検索を自動的に送信します。    
  
### <a name="web-browser-to-web-app"></a>Web ブラウザーで Web アプリ   
このシナリオで、ユーザーのブラウザーでは、web アプリケーションによってホストされているリソースにアクセスする必要があります。    
このための 2 つのシナリオがあります。  
  
#### <a name="oauth-confidential-client"></a>Oauth の confidential クライアント  
このシナリオでは、トークンの交換用のコードを続けて、承認要求があることで、上記に似ています。  (AD FS でのサーバー アプリケーションとしてモデル化)、web アプリがブラウザー経由で承認要求を開始し、(AD FS に直接接続する) をトークンのコードを交換します。  
  
![プロトコル フローの説明](media/ADFS_DEV_4.png)  
  
1.  承認エンドポイントの承認が AD FS に HTTP GET を送信すると、ブラウザーを使用して要求、Web アプリを開始します  
**承認要求**:  
取得 https://fs.contoso.com/adfs/oauth2/authorize?  
  
パラメーター|値  
---------|---------  
response_type|「コード」  
resource|アプリケーション グループ内の Web API の RP ID (識別子)  
client_id|アプリケーション グループでネイティブ アプリケーションのクライアント Id  
redirect_uri|リダイレクト URI のアプリケーション グループ内の web アプリ (サーバー アプリケーション)  
  
承認要求の応答:  
ユーザーが署名されていない場合する前に、資格情報の入力が求められます。  
AD FS は、たとえば、redirect_uri のクエリ コンポーネントでの"code"パラメーターとして、認証コードを返すことで応答します。Http/1.1 302 検出場所: https://webapp.contoso.com/?code=&lt; コード&gt;します。  
  
2.  上記の 302 の結果として、ブラウザーを開始します、web アプリに HTTP GET など。取得 http://redirect_uri:80/?code=&lt; コード&gt;します。   
  
3.  この時点で、コードの受信、web アプリは、次の送信、AD FS のトークン エンドポイントに対する要求を開始します。  
**トークンの要求:**  
投稿 https://fs.contoso.com/adfs/oauth2/token  
  
パラメーター|値  
---------|---------  
grant_type|"authorization_code"  
code|上記の 2 から認証コード  
resource|アプリケーション グループ内の Web API の RP ID (識別子)  
client_id|アプリケーション グループでは、web app (サーバー アプリケーション) のクライアント Id  
redirect_uri|リダイレクト URI のアプリケーション グループ内の web アプリ (サーバー アプリケーション)  
client_secret|アプリケーション グループでは、web app (サーバー アプリケーション) のシークレット。 **注:クライアントの資格情報は、client_secret をする必要はありません。AD FS にも証明書または Windows 統合認証を使用する機能がサポートしています。**  
  
**トークン要求の応答:**  
AD FS は、access_token、refresh_token を本文に id_token と、HTTP 200 で応答します。  
要求  
4.  Web アプリケーションのいずれか (例では、web アプリ自体がリソースをホストする)、上記の応答の access_token の一部を消費し、またはそれ以外の場合、HTTP 要求の承認ヘッダーとして web API に送信します。  
  
#### <a name="single-sign-on-behavior"></a>シングル サインオンの動作  
アクセス トークンがまだ有効だが 1 時間 (既定)、クライアントのキャッシュに、2 番目の要求が動作するネイティブ クライアントのシナリオ - 上記と同様にエントリのアクセス トークンが自動的には、新しい要求が AD FS へのトラフィックがトリガーされないと思われる場合があります。ADAL によってキャッシュからフェッチします。  ただし、個別の承認と、以前のサンプルのように、個別の URL リンクを使用して、トークンの要求が web アプリを送信できることができます。  
  
この場合は資格情報を求めることがなく新しい認証コードを発行する AD FS を使用する AD FS のブラウザー SSO クッキー。 Web アプリは、次の新しいアクセス トークンを新しい承認コードを交換する AD FS を呼び出します。  ユーザーが資格情報を求められません。  
  
それ以外の場合、web アプリがある場合は、承認要求をスキップすることができます、ユーザーが既に認証されている場合を把握するのに十分なと、スマートします。  
* キャッシュされたアクセス トークン、期限が切れていない場合取得され、使用、または   
* 以下に示すよう、AD FS のトークン エンドポイントに要求トークンに基づいて要求を送信できます。  
  
**更新トークンの要求。**  
投稿 https://fs.contoso.com/adfs/oauth2/token
   
パラメーター|Value  
---------|---------  
grant_type|"refresh_token"  
resource|アプリケーション グループ内の Web API の RP ID (識別子)  
client_id|アプリケーション グループでは、web app (サーバー アプリケーション) のクライアント Id  
refresh_token|最初のトークン要求に対する応答の AD FS によって発行されたトークンを更新します。  
client_secret|アプリケーション グループで、web アプリ (サーバー アプリケーション) のシークレット  
  
**トークン要求の応答を更新します。**  
更新トークンが < SSO_period > 内にある場合は、新しいアクセス トークン要求が発生します。 ユーザーが資格情報を求められません。 詳細については、SSO の設定を参照してください[AD FS Single Sign On Settings](../../ad-fs/operations/AD-FS-2016-Single-Sign-On-Settings.md)   
  
更新トークンの有効期限が切れている場合、要求が HTTP 401 エラー"invalid_grant"と"error_description"と"MSIS9615:Refresh_token パラメーターで受け取った更新トークンが期限切れ"です。 この場合、ADAL は、新しい承認要求は 1 つ目のように検索を自動的に送信します。    
  
#### <a name="openid-connect-hybrid-flow"></a>OpenID 接続します。ハイブリッド フロー  
このシナリオは、ブラウザーのリダイレクトと AD FS に web アプリからのトークンの交換用のコードを使用して web アプリによって開始された承認要求がありますにするには、上記に似ています。  このシナリオでの違いは、AD FS が初期認証要求の応答の一部として、id_token を発行することです。  
  
![プロトコル フローの説明](media/ADFS_DEV_5.png)  
  
1.  承認エンドポイントの承認が AD FS に HTTP GET を送信すると、ブラウザーを使用して要求、Web アプリを開始します  
  
**承認要求:**  
取得 https://fs.contoso.com/adfs/oauth2/authorize?  
  
パラメーター|値  
---------|---------  
response_type|"code+id_token"  
response_mode|"form_post"  
resource|アプリケーション グループ内の Web API の RP ID (識別子)  
client_id|アプリケーション グループでは、web app (サーバー アプリケーション) のクライアント Id  
redirect_uri|リダイレクト URI のアプリケーション グループ内の web アプリ (サーバー アプリケーション)  
  
**承認要求の応答:**  
ユーザーが署名されていない場合する前に、資格情報の入力が求められます。  
AD FS が HTTP 200 とフォームを含む応答、として非要素の下。  
* コード: 承認コード  
* id_token: ユーザー認証を記述するクレームを含む JWT トークン  
2.  フォームは、コードと id_token を web アプリに送信する、web アプリの redirect_uri を自動的に送信します。  
  
3.  この時点で、コードの受信、web アプリは、次の送信、AD FS のトークン エンドポイントに対する要求を開始します。  
  
**トークンの要求:**  
投稿 https://fs.contoso.com/adfs/oauth2/token
  
  
  
パラメーター|値  
---------|---------  
grant_type|"authorization_code"  
code|上記の承認コード  
resource|アプリケーション グループ内の Web API の RP ID (識別子)  
client_id|アプリケーション グループでは、web app (サーバー アプリケーション) のクライアント Id  
redirect_uri|リダイレクト URI のアプリケーション グループ内の web アプリ (サーバー アプリケーション)  
client_secret|アプリケーション グループで、web アプリ (サーバー アプリケーション) のシークレット  
  
**トークン要求の応答:**  
AD FS は、access_token、refresh_token を本文に id_token と、HTTP 200 で応答します。  
  
4.  Web アプリケーションのいずれか (例では、web アプリ自体がリソースをホストする)、上記の応答の access_token の一部を消費し、またはそれ以外の場合、HTTP 要求の承認ヘッダーとして web API に送信します。  
  
#### <a name="single-sign-on-behavior"></a>シングル サインオンの動作  
動作で、シングル サインオンは、上記の Oauth 2.0 confidential クライアント フローの場合と同じです。  
  
### <a name="on-behalf-of"></a>代わりに  
このシナリオで web アプリはユーザーからの元のアクセス トークンを使用して要求して、エンド ユーザーとして web アプリにアクセスし、別の Web API の別のアクセス トークンを取得します。  これは「の代わりに」フローと呼ばれます。  
  
![プロトコル フローの説明](media/ADFS_DEV_6.png)  
  
手順 3. ~ 4. に前のフローと同じように手順 1. および 2. 作業します。  
手順 3 では、重要な要件は、client_id パラメーター 2 では、Web アプリのクライアント ID が、RP ID Web API の A. に一致する必要があります。 つまり、新しいトークンに交換するアクセス トークンの対象ユーザーは、新しいトークンを要求したエンティティのクライアント ID と一致する必要があります。  

## <a name="related-content"></a>関連コンテンツ  
参照してください[AD FS の開発](../AD-FS-Development.md)チュートリアル記事の完全な一覧、関連するフローを使用して詳細な手順を説明します。 
