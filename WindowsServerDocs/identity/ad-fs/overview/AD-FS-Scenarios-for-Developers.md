---
ms.assetid: 8a64545b-16bd-4c13-a664-cdf4c6ff6ea0
title: "開発者向けの AD FS のシナリオ"
description: 
author: billmath
ms.author: billmath
manager: femila
ms.date: 05/31/2017
ms.topic: article
ms.prod: windows-server-threshold
ms.technology: identity-adfs
ms.openlocfilehash: 753b2b235cb1d73ab47588f8f229410c1f81db40
ms.sourcegitcommit: db290fa07e9d50686667bfba3969e20377548504
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/12/2017
---
# <a name="ad-fs-scenarios-for-developers"></a>開発者向けの AD FS のシナリオ

>Windows Server 2016 の適用対象:

Windows Server 2016 の AD FS 2016 での AD FS を使用すると、業界標準 OpenID 接続し、OAuth 2.0 ベースの認証と承認を開発しているアプリケーションを追加し、それらのアプリケーションが AD FS に対して直接ユーザーを認証できます。    
  
AD FS 2016 には、Ws-federation、Ws-trust もサポートしています、SAML プロトコルのプロファイルは以前のバージョンではサポートされています。  これらのプロトコルの開発者向けガイダンスに興味がある場合、は、こちらの記事を参照してください。  この記事を使用し、それ以降のプロトコルのサポートを利用する方法に焦点を当てます。  
  
## <a name="why-modern-authentication"></a>なぜ最新の認証  
Ws-federation で、AD FS で記号の使用を継続できますが、Ws-trust、と同様の SAML プロトコルがある前に、それ以降のプロトコルでは、次の利点を取得します。  
  
* **簡潔さや整合性**  
    * サインインを有効にするのにには、同じ Api とパターンのセットを使用します。   
        *   複数の種類のアプリケーション (サーバー、デスクトップ、モバイル、ブラウザー)  
        *   複数のプラットフォーム (android、iOS、Windows)  
        *   企業ネットワーク内のアプリケーションまたはホスト型クラウドに  
    * 既に Azure AD に対するユーザーの認証に使用できるライブラリの同じセットを使用します。  
* **柔軟性**  
    * だけでなく標準ユーザーの承認より複雑なシナリオをなど、有効にします。      
        * ? 3 脚サインオン フローを 1 つの web アプリケーションまたはサービスを別の web アプリやサービスに存在するリソースにアクセスするユーザーを承認します。    
        * ? 中間層サービス バック エンド API にアクセスするサーバー間のフロー  
        * ? JavaScript ベースのシングル ページ アプリケーション (SPA)  
* **業界サポート**  
    * OAuth 2.0 および OpenID 接続を楽しむ幅の使用率、業界全体でので、これらのパターンの知識は認証と同様に、Active Directory 環境の外部での承認を有効にします。  
  
## <a name="how-it-works-the-basics"></a>そのしくみ: の基本  
AD FS の最新の認証は、同じ一連のツールおよびライブラリーが既に Azure AD に対するユーザーの認証に使用することができますを使用してアプリケーションを追加できます。   
  
AD FS のシナリオでもちろん、これは AD FS といない Azure AD id プロバイダーと承認として機能するサーバー。  それ以外の場合、概念、まったく同じです。 ユーザーが自分の資格情報を提供すると、直接またはリソースへのアクセスを中継せず経由でのトークンを取得します。  
  
最も基本的なシナリオでは、ユーザーまたは「リソース所有者」、web アプリケーションにアクセスするブラウザーを操作するので構成されます。  
  
![開発者向けの AD FS](media/ADFS_DEV_1.png)  
  
リソースにアクセス トークンの要求を承認サーバー (AD FS) を開始するため、web アプリケーションは「クライアント」と呼ばれます。  リソースは、web アプリ自体でホストされる可能性がありますか、ネットワークまたはインターネット上の web API としてアクセス可能な場合があります。   ユーザーまたは「リソース所有者」承認サーバーに資格情報を提供することによってそのアクセス トークンを受信するクライアント web アプリを承認します。    
  
## <a name="how-it-works-components"></a>そのしくみ: コンポーネント  
OAuth 2.0 と OpenID 接続のシナリオで AD FS 同じ一連のツールおよびライブラリーが Azure AD は、id プロバイダーときに使用するを使用します。  これらのコンポーネントは次のとおりです。  
* Active Directory 認証ライブラリ (ADAL): クライアント ライブラリを促進するユーザーの資格情報を収集する、作成およびトークン要求を送信し、結果として得られるトークンを取得します。    
* OWIN (開いている Web インターフェイス .NET) ミドルウェア: 中に OWIN コミュニティ ベース プロジェクトは、Microsoft が作成された一連のサーバー側の保護の web アプリケーションおよびライブラリで OpenID 接続し、OAuth 2.0 Api を web  
  
次の図では、これらのコンポーネントの役割が表示されます。  
  
![開発者向けの AD FS](media/ADFS_DEV_2.png)  
  
## <a name="modeling-these-scenarios-in-ad-fs-2016"></a>AD FS 2016 でこれらのシナリオのモデリング  
  
### <a name="application-groups"></a>アプリケーション グループ  
AD FS のポリシーでこれらのシナリオを表す、アプリケーション グループと呼ばれる新しい概念が導入されました。  アプリケーション グループには、任意の数と、次の基本的な種類のアプリケーションの組み合わせを含めることができます。  
  
  
  
アプリケーション グループ/アプリケーションのように入力  |説明  |ロール    
---------|---------|---------  
ネイティブ アプリケーション     |  パブリック クライアントとも呼ばれる、ユーザーが操作して、pc やデバイスで実行しているクライアント アプリであるこのものです。       | リソースにユーザーがアクセスできる認証サーバー (AD FS) からのトークンを要求します。  HTTP ヘッダーにトークンを使用して、保護されたリソースへの HTTP 要求を送信します。        
サーバー アプリケーション     |   サーバー上で実行し、通常、ユーザーがアクセスできる、ブラウザー経由で web アプリケーションです。  独自のクライアント 'シークレット' または資格情報を維持するための対応であるためにとも呼ば機密性の高いクライアント。      | リソースにユーザーがアクセスできる認証サーバー (AD FS) からのトークンを要求します。  HTTP ヘッダーにトークンを使用して、保護されたリソースへの HTTP 要求を送信します。               
Web API     |  リソースのエンド ユーザーがアクセスしています。 これらの「証明書利用者」の新しい表現としてと考えてください。| クライアントが取得したトークンを使用します。  
  
### <a name="differences-from-ad-fs-2012-r2"></a>AD FS 2012 R2 との相違点  
アプリケーション グループとして証明書利用者、クライアント、およびアプリケーションのアクセス許可とは別に、公開されている AD FS 2012 R2 の信頼と承認の要素を結合します。  
  
次の表は、対応するアプリケーションが作成される信頼オブジェクト AD FS 2012 R2 で AD FS 2016 vs メソッドを比較します。  
  
Windows Server 2012 R2 で AD FS|PowerShell で|AD FS の管理  
---------|---------|---------  
ネイティブ クライアントを追加します。|追加 AdfsClient|NA  
クライアントとサーバー アプリケーションを追加します。|追加 AdfsClient|NA  
Web API を追加/リソース|追加 AdfsRelyingPartyTrust|証明書利用者信頼を作成します。  
  
AD FS 2016|PowerShell で|AD FS の管理  
---------|---------|---------  
ネイティブ クライアントを追加します。|追加 AdfsNativeClientApplication|ネイティブ アプリケーション グループを追加します。  
クライアントとサーバー アプリケーションを追加します。|追加 AdfsServerApplication|サーバー アプリケーション グループを追加します。  
Web API を追加/リソース|追加 AdfsWebApiApplication|Web API アプリケーション グループを追加します。  
  
### <a name="application-permissions-and-consent"></a>アプリケーションのアクセス許可と同意  
既定では、アプリケーション グループ内のクライアントは、同じグループ内のリソースにアクセス許可します。  管理者は、特定のアプリケーションのアクセス許可の構成はありません。  アプリケーション グループには、管理者が許可されている、openid や user_impersonation など、スコープを指定することもできます。  以下のシナリオの説明は、スコープがどのシナリオに必要な正確に指定します。  
  
AD FS では、管理者の承認のモデルを使用するため、ユーザーは、リソースにアクセスするときに同意しない求め。  アプリケーション グループを構成すると、管理者は有効で、アプリケーションのすべてのユーザーに代わって同意を提供します。  
  
## <a name="supported-scenarios"></a>サポートされるシナリオ  
次のセクションでは、さらに詳しくサポートのシナリオについて説明します。  
  
### <a name="tokens-used"></a>トークンの使用  
これらのシナリオのための 3 つのトークンの種類を使用します。  
  
* **id_token:** A JWT トークンがユーザーの id を表すために使用します。 Id_token の 'aud' または対象ユーザーの要求では、ネイティブまたはサーバー アプリケーションのクライアント ID と一致します。  
* **access_token:** A JWT トークンの Oauth OpenID 接続シナリオと、リソースが消費するために使用します。  このトークンの 'aud' または対象ユーザーの要求は、リソースまたは Web API の識別子と一致する必要があります。  
* **refresh_token:**エクスペリエンスでシングル サインオンを提供するユーザーの資格情報を収集する代わりにこのトークンを送信します。  このトークンが発行され、AD FS によって消費されると、クライアントまたはリソースによって読み取ることができません。    
  
### <a name="native-client-to-web-api"></a>Web API をネイティブ クライアント  
このシナリオでは、AD FS 2016 保護されている Web API を呼び出すネイティブ クライアント アプリケーションのユーザーを使用できます。  
* クライアントのネイティブ アプリケーションでは、ADAL を使用して、認証を送信し、トークンを、必要に応じて、ユーザーからの資格情報の入力を求める AD FS に要求し、送信 Web API への要求で HTTP ヘッダーとして、結果として得られるトークン  
* [この部分はデモ目的のみ]Web API は、クライアントによって送信されたアクセス トークンに起因し、クライアントに送信する ClaimsPrincipal オブジェクトから、信頼性情報を読み取ります。  
  
![プロトコルのフローの説明](media/ADFS_DEV_3.png)  
  
1.  クライアントのネイティブ アプリケーションでは、ADAL ライブラリへの呼び出しを使用したフローを開始します。  ブラウザー ベースのトリガーこのエンドポイントを承認する AD FS への HTTP を取得します。  
  
**承認要求:**  
GET https://fs.contoso.com/adfs/oauth2/authorize?  
  
パラメーター|値  
---------|---------  
response_type|「コード」  
リソース|アプリケーション グループ内の Web API の RP ID (Id)  
client_id|クライアントのネイティブ グループ内のアプリケーション、アプリケーションの Id  
redirect_uri|アプリケーション グループ内のネイティブ アプリケーションの URI にリダイレクトします。  
  
**承認要求の応答:**  
場合は、ユーザーがサインインしていないする前に、資格情報の入力が求められます。    
AD FS は、redirect_uri のクエリのコンポーネントで「コード」パラメーターとして認証コードを返すことで応答します。  例: http/1.1 302 見つかった場所: **http://redirect_uri:80/? コード =&lt;コード&gt;します。**  
  
2.  ネイティブ クライアントは、次のパラメーターと共に、コードを AD FS トークン エンドポイントに送信します。  
  
**トークンの要求。**  
POST https://fs.contoso.com/adfs/oauth2/token  
  
パラメーター|値  
---------|---------  
grant_type|"authorization_code" 
コード|1 から認証コード  
リソース|アプリケーション グループ内の Web API の RP ID (Id)  
client_id|クライアントのネイティブ グループ内のアプリケーション、アプリケーションの Id  
redirect_uri|アプリケーション グループ内のネイティブ アプリケーションの URI にリダイレクトします。  
  
**トークンの要求の応答:**  
AD FS は、HTTP 200 access_token、refresh_token、本文に id_token とで応答します。  
  
3.  次に、ネイティブ アプリケーションでは、web API を HTTP 要求の承認ヘッダーとして、access_token、上記の応答の一部を送信します。  
  
### <a name="single-sign-on-behavior"></a>シングル サインオンの動作  
それ以降のクライアントを要求内で 1 時間 (既定)、access_token がまだ有効になります、キャッシュ内および新しい要求は AD FS へのトラフィックはトリガーされません。  Access_token ADAL によって、キャッシュから自動的にフェッチされません。  
  
アクセス トークンを過ぎると、ADAL は自動的に送信されている、AD FS トークン エンドポイント (認証要求を自動的にスキップ) を更新トークンに基づいて要求を使用します。  
**トークンの要求を更新します。**  
POST https://fs.contoso.com/adfs/oauth2/token
   

パラメーター|値|
---------|---------
grant_type|"refresh_token"|
リソース|アプリケーション グループ内の Web API の RP ID (Id)|
client_id|クライアントのネイティブ グループ内のアプリケーション、アプリケーションの Id
refresh_token|最初のトークン要求に応答の AD FS によって発行された更新トークン

  
  
**トークンの要求の応答を更新します。**  
更新トークンが < SSO_period > 内にある場合は、新しいアクセス トークンの要求が発生します。 ユーザーは資格情報を求めません。  詳細については、SSO の設定を参照してください[AD FS シングル サインオンでの設定](../../ad-fs/operations/AD-FS-2016-Single-Sign-On-Settings.md)  
  
更新トークンの有効期限が切れた場合、要求結果に HTTP 401 エラー"invalid_grant"および"error_description"と"MSIS9615: refresh_token パラメーターで受け取った更新トークンの有効期限が切れて"です。 この場合、ADAL は自動的に次の 1 つ目と同じような新しい承認要求を送信します。    
  
### <a name="web-browser-to-web-app"></a>Web ブラウザーで Web アプリ   
このシナリオで、ユーザーがブラウザーは、web アプリケーションでホストされているリソースにアクセスする必要があります。    
これには 2 つのシナリオがあります。  
  
#### <a name="oauth-confidential-client"></a>Oauth 機密クライアント  
このシナリオでは、トークンの exchange のコードを続けて、承認の要求が上記に似ています。  (AD FS でのサーバー アプリケーションとしてモデル化) web アプリは、ブラウザー経由で認証要求を開始し、(に直接接続して AD FS) のトークンのコードを交換  
  
![プロトコルのフローの説明](media/ADFS_DEV_4.png)  
  
1.  AD FS に HTTP GET を送信すると、ブラウザー経由での承認を要求する Web アプリ開始エンドポイントを承認します。  
**承認要求**:  
GET https://fs.contoso.com/adfs/oauth2/authorize?  
  
パラメーター|値  
---------|---------  
response_type|「コード」  
リソース|アプリケーション グループ内の Web API の RP ID (Id)  
client_id|ネイティブ グループ内のアプリケーション、アプリケーションのクライアント Id  
redirect_uri|アプリケーション グループ内の web アプリ (サーバー アプリケーション) の URI にリダイレクトします。  
  
承認要求の応答:  
場合は、ユーザーがサインインしていないする前に、資格情報の入力が求められます。  
たとえば、redirect_uri のクエリのコンポーネントで「コード」パラメーターとして認証コードを返すことで応答する AD FS: http/1.1 302 見つかった場所: https://webapp.contoso.com/?code=&lt;コード&gt;します。  
  
2.  上記の 302 の結果として、ブラウザーを開始、web アプリに HTTP GET 例: GET http://redirect_uri:80/? コード =&lt;コード&gt;します。   
  
3.  この時点で、コードを受信したが、web アプリが、AD FS トークン エンドポイントで、次を送信する要求を開始します。  
**トークンの要求。**  
POST https://fs.contoso.com/adfs/oauth2/token  
  
パラメーター|値  
---------|---------  
grant_type|"authorization_code"  
コード|上記の 2 から認証コード  
リソース|アプリケーション グループ内の Web API の RP ID (Id)  
client_id|アプリケーション グループ内の web アプリケーション (サーバー アプリケーション) のクライアント Id  
redirect_uri|アプリケーション グループ内の web アプリ (サーバー アプリケーション) の URI にリダイレクトします。  
client_secret|アプリケーション グループでの web アプリ (サーバー アプリケーション) のシークレットします。 **注: クライアントの資格情報は、client_secret である必要はありません。  AD FS には、証明書または Windows 統合認証をも使用する機能がサポートしています。**  
  
**トークンの要求の応答:**  
AD FS は、HTTP 200 access_token、refresh_token、本文に id_token とで応答します。  
信頼性情報  
4.  Web アプリケーションの (場合でも、web アプリ自体がリソースをホストする)、上記の応答の access_token 部分を占めてするか、またはそれ以外の場合、HTTP 要求の承認ヘッダーとして web API に送信します。  
  
#### <a name="single-sign-on-behavior"></a>シングル サインオンの動作  
アクセス トークンがまだ有効になります (既定) 1 時間に、クライアントのキャッシュに、中には、2 番目の要求が機能する上でのネイティブ クライアント シナリオと同様にエントリの ADAL によってに、アクセス トークンがキャッシュからフェッチ自動的に、新しい要求は AD FS へのトラフィックがトリガーされないと考える可能性があります。  ただし、web アプリは、さまざまな承認およびトークン要求を送信できることは、サンプルと同様に、個別の URL を使用して、以前のリンクです。  
  
この場合は、により、AD FS の資格情報をユーザーに確認しないで、新しい認証コードを発行する AD FS ブラウザー SSO の cookie を勧めします。 新しいアクセス トークンの新しい承認コードを交換する AD fs web アプリを呼び出します。  ユーザーは資格情報を求めません。  
  
そうしないと場合は、web アプリがスマートする場合、ユーザーが既に認証、承認要求をスキップできますがわかっているのに十分なといずれか。  
* キャッシュされたアクセス トークンでは、期限が切れていない場合取得され、使用、または   
* 要求のトークン ベース要求は、以下に示すよう、AD FS トークン エンドポイントに送信できます。  
  
**トークンの要求を更新します。**  
POST https://fs.contoso.com/adfs/oauth2/token
   
パラメーター|値  
---------|---------  
grant_type|"refresh_token"  
リソース|アプリケーション グループ内の Web API の RP ID (Id)  
client_id|アプリケーション グループ内の web アプリケーション (サーバー アプリケーション) のクライアント Id  
refresh_token|最初のトークン要求への応答の AD FS によって発行されたトークンを更新します。  
client_secret|アプリケーション グループでの web アプリ (サーバー アプリケーション) のシークレット  
  
**トークンの要求の応答を更新します。**  
更新トークンが < SSO_period > 内にある場合は、新しいアクセス トークンの要求が発生します。 ユーザーは資格情報を求めません。 詳細については、SSO の設定を参照してください[AD FS シングル サインオンでの設定](../../ad-fs/operations/AD-FS-2016-Single-Sign-On-Settings.md)   
  
更新トークンの有効期限が切れた場合、要求結果に HTTP 401 エラー"invalid_grant"および"error_description"と"MSIS9615: refresh_token パラメーターで受け取った更新トークンの有効期限が切れて"です。 この場合、ADAL は自動的に次の 1 つ目と同じような新しい承認要求を送信します。    
  
#### <a name="openid-connect-hybrid-flow"></a>OpenID 接続: ハイブリッド フロー  
このシナリオは、ブラウザー リダイレクトでは、や web アプリから AD fs トークンの exchange のコードを介した web アプリによって認証要求を開始したが上記に似ています。  このシナリオでは、違いは、AD FS の初期認証要求の応答の一部として、id_token を発行します。  
  
![プロトコルのフローの説明](media/ADFS_DEV_5.png)  
  
1.  AD FS に HTTP GET を送信すると、ブラウザー経由での承認を要求する Web アプリ開始エンドポイントを承認します。  
  
**承認要求:**  
GET https://fs.contoso.com/adfs/oauth2/authorize?  
  
パラメーター|値  
---------|---------  
response_type|「コード + id_token」  
response_mode|"form_post"  
リソース|アプリケーション グループ内の Web API の RP ID (Id)  
client_id|アプリケーション グループ内の web アプリケーション (サーバー アプリケーション) のクライアント Id  
redirect_uri|アプリケーション グループ内の web アプリ (サーバー アプリケーション) の URI にリダイレクトします。  
  
**承認要求の応答:**  
場合は、ユーザーがサインインしていないする前に、資格情報の入力が求められます。  
AD FS が応答すると、HTTP 200 フォームを含む、として隠し要素の下。  
* コード: 認証コード  
* id_token: JWT トークンがユーザー認証を記述する信頼性情報が含まれています。  
2.  形式は、redirect_uri web アプリ、web アプリをコードと、id_token を送信するのに自動的に投稿します。  
  
3.  この時点で、コードを受信したが、web アプリが、AD FS トークン エンドポイントで、次を送信する要求を開始します。  
  
**トークンの要求。**  
POST https://fs.contoso.com/adfs/oauth2/token
  
  
  
パラメーター|値  
---------|---------  
grant_type|"authorization_code"  
コード|上から認証コード  
リソース|アプリケーション グループ内の Web API の RP ID (Id)  
client_id|アプリケーション グループ内の web アプリケーション (サーバー アプリケーション) のクライアント Id  
redirect_uri|アプリケーション グループ内の web アプリ (サーバー アプリケーション) の URI にリダイレクトします。  
client_secret|アプリケーション グループでの web アプリ (サーバー アプリケーション) のシークレット  
  
**トークンの要求の応答:**  
AD FS は、HTTP 200 access_token、refresh_token、本文に id_token とで応答します。  
  
4.  Web アプリケーションの (場合でも、web アプリ自体がリソースをホストする)、上記の応答の access_token 部分を占めてするか、またはそれ以外の場合、HTTP 要求の承認ヘッダーとして web API に送信します。  
  
#### <a name="single-sign-on-behavior"></a>シングル サインオンの動作  
シングル サインオンの動作は、上記の Oauth 2.0 機密性の高いクライアント フローと同じです。  
  
### <a name="on-behalf-of"></a>代理で  
このシナリオで web アプリを使ってユーザーから元のアクセス トークンを要求し、エンドユーザーと web アプリにアクセスし、別の Web API の別のアクセス トークンを取得します。  これは、「の代理で」フローと呼ばれます。  
  
![プロトコルのフローの説明](media/ADFS_DEV_6.png)  
  
手順 1 と 2 は、3 および 4 以前のフローを手順と同じように動作します。  
手順 3 で、重要な要件は client_id パラメーター、2、Web アプリのクライアント ID と一致するが、RP ID の Web API A.つまり、新しいトークンに交換されるアクセス トークンの対象ユーザー、新しいトークンを要求しているエンティティのクライアント ID と一致する必要があります。  

## <a name="related-content"></a>関連するコンテンツ  
参照してください[AD FS の開発](../AD-FS-Development.md)ウォークスルー記事の完全な一覧に関連するフローを使用して手順を説明します。 
